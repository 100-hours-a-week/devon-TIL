# [TIL] 응집도·결합도

- 2025.11.01


<br>

## 📖 정의

### ✅ **응집도(Cohesion)**

 모듈 내부 요소들이 얼마나 밀접하게 관련되어 있는가를 나타내는 척도.
 

> 즉, **하나의 모듈이 단일한 목적을 얼마나 잘 수행하느냐**를 의미함.
 

### ✅ **결합도(Coupling)**

 모듈 간 의존성 정도를 의미함.
  
> 즉, **하나의 모듈이 다른 모듈에 얼마나 의존하느냐**를 나타냄.
 



<img width="500" height="436" alt="CouplingVsCohesion" src="https://github.com/user-attachments/assets/e404752b-d31e-41fa-8a4f-e551e5f58bd4" />


<br>



## ✨ 특징

### 응집도


- **높을수록 좋음 (High Cohesion 👍)**
- 응집도가 높으면 **유지보수성과 재사용성**이 높아짐.

| 응집도 수준 | 설명 | 예시 |
| --- | --- | --- |
| 기능적 응집 (Functional) | 하나의 기능만 수행 | `OrderService.placeOrder()` |
| 순차적 응집 (Sequential) | 한 작업의 출력이 다음 작업의 입력이 됨 | 파일 읽고 → 파싱 → 저장 |
| 통신적 응집 (Communicational) | 동일한 데이터에 대해 여러 작업 수행 | 같은 DB 테이블 조작 |
| 절차적 응집 (Procedural) | 순서상 함께 수행되는 작업 | 로그인 후 세션 생성 |
| 시간적 응집 (Temporal) | 특정 시점에 함께 실행되는 초기화 코드 | 앱 시작 시 리소스 로드 |
| 논리적 응집 (Logical) | 논리적으로 유사한 기능을 모음 | 파일 처리, 프린트 처리 등 |
| 우연적 응집 (Coincidental) | 아무 관련 없는 코드들이 모여 있음 | “잡동사니” 유틸 클래스 |

<br>

## 예시

### 1. **우연적 응집 (Coincidental Cohesion)** ❌ *가장 나쁨*

서로 관계없는 기능이 한 클래스에 모여 있음.

```java
public class Utility {
    public void printUserName(Member member) { ... }
    public void calculateTax() { ... }
    public void sendEmail() { ... }
}
```

> → 기능들이 서로 아무 관련 없음.
> 
> 
> → "그냥 유틸"처럼 묶여 유지보수가 어려움.
> 

---

### 🔹 2. **논리적 응집 (Logical Cohesion)** ⚠️

논리적으로 유사해 보이는 기능을 하나로 묶음.

```java
public class FileProcessor {
    public void processImage(File file) { ... }
    public void processText(File file) { ... }
    public void processVideo(File file) { ... }
}
```

> → “파일 처리”라는 공통점은 있지만, 내부 로직이 완전히 다름.
> 
> 
> → 각 타입별 클래스로 분리하는 게 좋음.
> 

---

### 🔹 3. **시간적 응집 (Temporal Cohesion)** ⚠️

특정 시점(예: 초기화 시)에 실행된다는 이유로 묶음.

```java
public class StartupInitializer {
    public void loadConfig() { ... }
    public void connectDB() { ... }
    public void startScheduler() { ... }
}
```

> → 전부 “시작 시점”이긴 하지만 역할은 제각각.
> 
> 
> → 초기화 로직을 각 컴포넌트별로 분리하는 것이 바람직.
> 

---

### 🔹 4. **절차적 응집 (Procedural Cohesion)** ⚠️

특정 순서로 수행되어야 한다는 이유로 묶음.

```java
public class RegisterProcess {
    public void validateInput() { ... }
    public void saveMember() { ... }
    public void sendWelcomeEmail() { ... }
}
```

> → 절차적으로 연결되어 있지만,
> 
> 
> → 각각 **검증**, **저장**, **이벤트 처리**라는 별도 책임을 가짐.
> 
> → 분리하면 응집도가 더 높아짐.
> 

---

### 🔹 5. **통신적 응집 (Communicational Cohesion)** ✅

같은 데이터를 중심으로 여러 기능이 수행됨.

```java
public class MemberStatisticsService {
    public void calculateLoginCount(Long memberId) { ... }
    public void updateLastLoginTime(Long memberId) { ... }
    public void calculateEngagementScore(Long memberId) { ... }
}
```

> → 모두 memberId 기반으로 회원 통계 처리라는 동일 데이터에 집중.
> 
> 
> → 꽤 응집도가 높음.
> 

---

### 🔹 6. **순차적 응집 (Sequential Cohesion)** ✅

한 기능의 출력이 다음 기능의 입력이 됨.

```java
public class ThumbnailGenerator {
    public byte[] extractFrame(VideoFile video) { ... }
    public Image resizeFrame(byte[] frame) { ... }
    public void saveThumbnail(Image image) { ... }
}
```

> → “썸네일 생성”이라는 하나의 흐름으로 연결됨.
> 
> 
> → 응집도 높음.
> 

---

## 🔹 7. **기능적 응집 (Functional Cohesion)** 💎 *가장 이상적*

모든 메서드가 **하나의 명확한 목적**을 수행.

```java
@Service
public class MemberRegistrationService {

    private final MemberRepository repository;
    private final EmailService emailService;

    @Transactional
    public Member register(String email, String password) {
        Member member = new Member(email, password);
        repository.save(member);
        emailService.sendWelcomeEmail(member);
        return member;
    }
}
```

> → **"회원 가입"**이라는 하나의 기능만 완성함.
> 
> 
> → 내부의 모든 메서드와 의존성이 같은 목적을 공유.
> 
> → **응집도 최상.**
>


### 결합도

- **낮을수록 좋음 (Low Coupling 👍)**
- 결합도가 낮으면 **유연하고 변경에 강한 구조**를 가짐.

| 결합도 수준 | 설명 | 예시 |
| --- | --- | --- |
| 데이터 결합 (Data Coupling) | 필요한 데이터만 전달 | `calculatePrice(int amount)` |
| 스탬프 결합 (Stamp Coupling) | 자료 구조 일부만 사용 | `process(Order order)` but only uses `order.id` |
| 제어 결합 (Control Coupling) | 제어 플래그로 흐름 제어 | `process(true)` → true면 저장, false면 삭제 |
| 외부 결합 (External Coupling) | 외부 환경에 의존 | 외부 파일, DB 설정 등 |
| 공통 결합 (Common Coupling) | 전역 변수 공유 | `public static var` 공유 |
| 내용 결합 (Content Coupling) | 내부 데이터 직접 접근 | 다른 클래스의 private 필드 접근 |

<br>

## 🔹 1. **내용 결합 (Content Coupling)** ❌ *가장 나쁨*

다른 클래스의 **내부 구현**을 직접 조작함.

```java
public class MemberService {
    private MemberRepository repository = new MemberRepository();

    public void deleteMember(Long id) {
        // 내부 필드 직접 접근 (private 수정 등)
        repository.members.remove(id);  // ❌ 캡슐화 위반
    }
}
```

> → MemberRepository 내부 컬렉션 구조가 바뀌면 MemberService도 수정해야 함.
> 
> 
> → **내부 구조 변경에 직접 영향받음.**
> 

---

## 🔹 2. **공통 결합 (Common Coupling)** ❌

전역 변수나 static 객체를 여러 클래스가 공유.

```java
public class GlobalConfig {
    public static String DB_URL = "jdbc:mysql://...";
}

public class MemberRepository {
    public void connect() {
        System.out.println("Connect to " + GlobalConfig.DB_URL);
    }
}

public class OrderRepository {
    public void connect() {
        System.out.println("Connect to " + GlobalConfig.DB_URL);
    }
}
```

> → 설정이 바뀌면 모든 클래스가 영향받음.
> 

---

## 🔹 3. **제어 결합 (Control Coupling)** ⚠️

메서드 인자로 **제어 플래그**를 전달해 내부 로직 제어.

```java
public class NotificationService {
    public void sendMessage(String message, boolean isEmail) {
        if (isEmail) sendEmail(message);
        else sendSMS(message);
    }
}
```

> → 호출자가 내부 제어 흐름을 알아야 함.
> 
> 
> → 로직이 분기될수록 결합도 증가.

---

## 🔹 4 외부 결합 (External Coupling) ⚠️

외부 시스템, 프로토콜, 인터페이스 형식 등에 의존.

```
public class PaymentService {
    // 외부 결제 API 형식에 직접 의존
    public void pay(ExternalPaymentRequest request) {
        ExternalPaymentApi.send(request);
    }
}
```

> → 외부 라이브러리나 API의 구조가 바뀌면 내부 코드도 수정 필요.
>
> → 인터페이스나 어댑터 계층으로 의존을 캡슐화하는 것이 좋다.
> 

---

## 🔹 5. **스탬프 결합 (Stamp Coupling)** ⚠️

큰 객체를 전달하지만 실제로는 일부 필드만 사용.

```java
public class OrderService {
    public void createOrder(Member member) {
        System.out.println("주문자 ID = " + member.getId());
        // 나머지 member 정보는 사용 안 함
    }
}
```

> → Member 구조가 바뀌면 OrderService도 수정될 수 있음.
> 
> 
> → DTO로 필요한 필드만 전달하는 것이 더 낫다.
> 

---

## 🔹 6. **데이터 결합 (Data Coupling)** ✅ *좋음*

필요한 데이터만 명시적으로 전달.

```java
public class OrderService {
    public void createOrder(Long memberId, String itemName) {
        System.out.println("회원 " + memberId + "가 " + itemName + " 주문");
    }
}
```

> → 가장 이상적인 결합도.
> 
> 
> → 최소한의 데이터만 의존, 변경에 강함.
>


