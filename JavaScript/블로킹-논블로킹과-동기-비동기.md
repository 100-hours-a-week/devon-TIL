# 블로킹/논블로킹과 동기/비동기로 시작하는 비동기 프로그래밍

## 들어가며

웹 애플리케이션을 개발하다 보면 파일을 읽거나, 데이터베이스에 쿼리를 날리거나, 외부 API를 호출하는 상황을 자주 마주하게 됩니다. 이런 작업들은 컴퓨터 기준에서 굉장히 느린 작업들이죠. 만약 이런 작업이 끝날 때까지 프로그램이 멈춰서 기다린다면 어떻게 될까요? 사용자는 화면이 멈춘 것처럼 느끼게 되고, 답답함을 느낄 겁니다.

이런 문제를 해결하기 위해 등장한 개념이 바로 **비동기 프로그래밍**입니다. 하지만 비동기를 제대로 이해하려면 **블로킹/논블로킹**과 **동기/비동기**라는 두 가지 축을 명확히 구분해야 합니다. 많은 개발자들이 이 개념들을 혼동하곤 하는데요, 오늘은 이 두 개념을 명확하게 정리해보겠습니다.

## 블로킹/논블로킹과 동기/비동기가 뭔가요?

이 개념들은 간단히 말해서 **작업을 처리하는 방식**에 대한 두 가지 관점입니다.

**블로킹/논블로킹**은 **제어권**의 관점입니다. 여기서 제어권이란 코드를 실행할 수 있는 권리를 의미합니다. 내가 어떤 함수를 호출했을 때, 그 함수가 자기 일을 다 마칠 때까지 나에게 제어권을 돌려주지 않고 붙들고 있느냐(블로킹), 아니면 일단 요청만 받고 제어권을 바로 돌려주느냐(논블로킹)의 차이입니다.

**동기/비동기**는 **순서와 결과 처리**의 관점입니다. 내가 어떤 함수에게 일을 시켰을 때, 그 일이 끝나는 순서와 내 코드의 실행 순서가 일치하는지, 그리고 그 결과는 어떻게 처리하는지에 대한 개념이죠.

예를 들어볼까요? void와 yaro가 인형 선물을 준비한다고 가정해봅시다.

**동기 방식**: void가 눈을 붙이는 작업(A)을 끝내고 결과물(인형)을 yaro에게 전달해야만 yaro가 포장 작업(B)을 시작할 수 있습니다. B작업은 반드시 A작업의 결과에 의존하고 그 순서가 지켜져야 합니다.

**비동기 방식**: void가 yaro에게 포장해달라고 요청하면 void는 자기 일을 알아서 진행할 수 있습니다. 서로 작업이 언제 끝날지 기다리지 않습니다. 작업이 끝나면 알려주기만 하면 되죠. 이 "알려주는 행위" 자체를 **콜백(Callback)**이라고 부릅니다.

## 어떤 상황에서 사용할까요?

**I/O 작업 처리**
파일 읽기/쓰기, 네트워크 요청처럼 사람의 기준에서는 빠르지만 컴퓨터 기준에서는 느린 작업을 처리할 때 프로그램의 반응성과 처리량을 극대화할 수 있습니다.

**웹 서버 개발**
동시에 여러 사용자의 요청을 처리해야 하는 웹 서버에서 블로킹 방식으로 동작하면 한 사용자의 요청이 끝날 때까지 다른 사용자들이 기다려야 합니다. 논블로킹/비동기 방식을 사용하면 효율적으로 여러 요청을 동시에 처리할 수 있습니다.

**UI 프로그래밍**
웹 브라우저에서 JavaScript는 기본적으로 싱글스레드입니다. 만약 블로킹 방식으로 동작한다면 UI 프리징 현상이 발생해 사용자 경험이 나빠집니다. 비동기 방식을 사용하면 화면이 멈추지 않습니다.

**데이터베이스 쿼리**
데이터베이스 쿼리는 네트워크를 통해 이루어지고 결과를 기다리는 시간이 깁니다. 이 시간 동안 다른 작업을 처리할 수 있다면 시스템 자원을 효율적으로 활용할 수 있습니다.

## 블로킹/논블로킹의 주요 특징

### 1. 제어권 중심 개념
블로킹/논블로킹은 호출된 함수가 제어권을 즉시 반환하는지에 관한 것입니다. 스레드를 차지하느냐에 대한 관점으로도 이해할 수 있습니다.

### 2. 블로킹의 특징
함수가 끝날 때까지 호출자가 기다립니다. 제어권을 계속 점유하고 있는 상태죠. 코드의 흐름이 위에서 아래로 순차적으로 진행되는 것처럼 보입니다.

### 3. 논블로킹의 특징
함수가 즉시 제어권을 반환하고, 호출자는 다른 일을 계속할 수 있습니다. 기다리는 시간 동안 다른 작업을 처리할 수 있어 시스템 자원을 효율적으로 활용할 수 있습니다.

## 동기/비동기의 주요 특징

### 1. 결과 처리와 순서 관점
동기/비동기는 요청한 작업의 완료 순서가 호출 흐름과 일치하느냐, 그리고 결과를 어떻게 받는지에 대한 개념입니다.

### 2. 동기의 특징
작업의 시작과 끝의 순서가 호출 순서와 일치합니다. 작업 완료 후 결과를 받을 때까지 다음 단계로 진행하지 않습니다. 대부분의 코드는 기본적으로 동기적으로 동작합니다.

### 3. 비동기의 특징
작업의 순서와 호출의 순서가 일치하지 않습니다. 작업 요청 후 바로 다음 작업을 진행하고, 완료되면 알림을 받습니다. 서로 작업 흐름이 별개로 진행됩니다.

## 핵심 개념 정리

블로킹과 논블로킹, 동기와 비동기를 정리하면 다음과 같습니다:

| 구분 | 블로킹/논블로킹 | 동기/비동기 |
|------|----------------|------------|
| 관점 | 제어권 관점 (스레드 제어) | 결과 처리·순서 관점 |
| 핵심 질문 | 지금 기다릴까? | 결과는 언제 받을까? |
| 블로킹/동기 | 끝날 때까지 제어권을 붙잡고 기다림 | 작업 완료 → 결과 받을 때까지 다음 단계 X |
| 논블로킹/비동기 | 즉시 제어권 반환, 다른 일 가능 | 요청 후 바로 다음 작업, 완료 시 알림 |

## 기본 사용법

### 동기 + 블로킹 방식

가장 기본적인 코드 실행 방식입니다. Node.js 환경에서 파일을 읽는 예시를 보겠습니다:

```javascript
const fs = require('fs');

console.log('파일 읽기 시작');
const data = fs.readFileSync('./file_path');
// readFileSync는 파일을 다 읽을 때까지 제어권을 돌려주지 않습니다 (Blocking)
// 그리고 파일 내용이 반환되어야 다음 코드가 실행됩니다 (Synchronous)

console.log('파일 읽기 완료', data);
```

실행 결과:
```
파일 읽기 시작
파일 읽기 완료 [파일 내용]
```

### 비동기 + 논블로킹 방식

JavaScript에서 핵심적인 모델입니다. A함수가 B함수를 호출하면 B는 요청만 받고 즉시 제어권을 A에게 돌려줍니다:

```javascript
const fs = require('fs');

console.log('파일 읽기 시작');

// readFile은 파일 읽기 '요청'만 하고 제어권을 즉시 반환합니다 (Non-Blocking)
// 파일 읽기가 끝나면 나중에 콜백 함수를 실행합니다 (Async)
fs.readFile('./file_path', (err, data) => {
    if(err) return err;
    console.log('파일 읽기 완료', data);
});

console.log('파일 읽기 요청 끝');
```

실행 결과:
```
파일 읽기 시작
파일 읽기 요청 끝
파일 읽기 완료 [파일 내용]
```

순서가 바뀐 것을 볼 수 있습니다. 이것이 비동기의 특징입니다.

## 4가지 조합 패턴

블로킹/논블로킹과 동기/비동기를 조합하면 4가지 패턴이 나옵니다:

### 1. 동기 + 블로킹

가장 일반적인 패턴입니다:

```javascript
const result = readFileSync('./file.txt');
console.log(result);
// 파일을 다 읽을 때까지 기다리고(블로킹),
// 순서대로 실행됩니다(동기)
```

### 2. 비동기 + 논블로킹

JavaScript에서 가장 많이 사용되는 패턴입니다:

```javascript
readFile('./file.txt', (err, data) => {
    console.log(data);
});
console.log('다음 작업 진행');
// 즉시 제어권 반환(논블로킹),
// 완료 시 콜백 실행(비동기)
```

### 3. 비동기 + 블로킹

비효율적인 패턴으로, 실무에서는 피해야 합니다:

```javascript
const promise = asyncFunction();
const result = promise.Result(); // .Result()로 기다림
// 비동기로 시작했지만 결과를 기다리므로 의미가 없습니다
```

### 4. 동기 + 논블로킹

주로 폴링(polling) 방식에서 사용됩니다:

```javascript
// 큐 상태를 즉시 확인하고 반환받지만,
// 결과는 즉시 사용합니다
const status = queue.checkStatus(); // 즉시 반환
if (status.hasData) {
    process(status.data);
}
```

## JavaScript와 비동기

### 싱글스레드인데 어떻게 비동기가 가능한가요?

JavaScript는 싱글스레드 언어입니다. 싱글스레드는 한 번에 하나의 작업만 처리할 수 있다는 의미죠. 그런데 어떻게 비동기 처리가 가능할까요?

그 비밀은 **이벤트 루프(Event Loop) + 콜백 큐(Callback Queue) + Web API(브라우저/런타임)**에 있습니다:

```javascript
console.log('1');

setTimeout(() => {
    console.log('2');
}, 0);

console.log('3');

// 출력:
// 1
// 3
// 2
```

실행 흐름:
1. `console.log('1')` 실행
2. `setTimeout`을 Web API에 위임하고 즉시 다음으로 진행
3. `console.log('3')` 실행
4. 이벤트 루프가 콜백 큐에서 `setTimeout`의 콜백을 가져와 실행

비동기는 스레드 개수와 무관합니다. 핵심은 "작업 완료 시점에 알림을 받는 방식"입니다.

## 실무에서 알아두면 좋은 것들

### 1. Promise와 async/await

콜백은 비동기 처리 방식 중 하나일 뿐입니다. 최신 JavaScript는 `Promise`와 `async/await`를 제공합니다:

```javascript
// Promise 방식
readFile('./file.txt')
    .then(data => console.log(data))
    .catch(err => console.error(err));

// async/await 방식
async function readData() {
    try {
        const data = await readFile('./file.txt');
        console.log(data);
    } catch (err) {
        console.error(err);
    }
}
```

`async/await`는 비동기 코드를 동기 코드처럼 작성할 수 있게 해줍니다.

### 2. fetch API 활용

웹 브라우저에서 API 호출 시 `fetch`를 사용합니다:

```javascript
console.log('요청 시작');

fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log('데이터:', data))
    .catch(error => console.error('에러:', error));

console.log('요청 완료');

// 출력:
// 요청 시작
// 요청 완료
// 데이터: {...}
```

`fetch`는 논블로킹/비동기 방식으로 동작합니다.

### 3. 여러 비동기 작업 동시 처리

여러 개의 비동기 작업을 동시에 처리하고 모든 결과를 기다려야 할 때 `Promise.all`을 사용합니다:

```javascript
const promises = [
    fetch('https://api.example.com/user/1'),
    fetch('https://api.example.com/user/2'),
    fetch('https://api.example.com/user/3')
];

Promise.all(promises)
    .then(responses => Promise.all(responses.map(r => r.json())))
    .then(users => console.log('모든 사용자:', users))
    .catch(error => console.error('에러:', error));
```

## 자주 하는 실수와 해결법

### 비동기 작업의 순서를 보장하지 않음

```javascript
// ❌ 잘못된 방법
let data;
fs.readFile('./file.txt', (err, result) => {
    data = result;
});
console.log(data); // undefined! 파일 읽기가 끝나기 전에 실행됨

// ✅ 올바른 방법 1: 콜백 안에서 처리
fs.readFile('./file.txt', (err, result) => {
    if (err) return console.error(err);
    console.log(result); // 올바른 결과
});

// ✅ 올바른 방법 2: async/await 사용
async function readData() {
    const data = await fs.promises.readFile('./file.txt');
    console.log(data); // 올바른 결과
}
```

### 콜백 지옥 (Callback Hell)

```javascript
// ❌ 잘못된 방법: 콜백 지옥
fs.readFile('file1.txt', (err, data1) => {
    if (err) return console.error(err);
    fs.readFile('file2.txt', (err, data2) => {
        if (err) return console.error(err);
        fs.readFile('file3.txt', (err, data3) => {
            if (err) return console.error(err);
            console.log(data1, data2, data3);
        });
    });
});

// ✅ 올바른 방법: async/await 사용
async function readFiles() {
    try {
        const data1 = await fs.promises.readFile('file1.txt');
        const data2 = await fs.promises.readFile('file2.txt');
        const data3 = await fs.promises.readFile('file3.txt');
        console.log(data1, data2, data3);
    } catch (err) {
        console.error(err);
    }
}
```

### Promise를 await 없이 사용

```javascript
// ❌ 잘못된 방법
async function fetchData() {
    const data = fetch('https://api.example.com/data'); // Promise 객체 자체가 저장됨
    console.log(data); // Promise { <pending> }
}

// ✅ 올바른 방법
async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data); // 실제 데이터
}
```

## 성능 최적화

### 1. 병렬 처리 활용

순차적으로 기다릴 필요가 없는 작업들은 병렬로 처리하세요:

```javascript
// ❌ 느린 방법: 순차 처리 (6초 소요)
async function slow() {
    const user = await fetchUser(); // 2초
    const posts = await fetchPosts(); // 2초
    const comments = await fetchComments(); // 2초
    return { user, posts, comments };
}

// ✅ 빠른 방법: 병렬 처리 (2초 소요)
async function fast() {
    const [user, posts, comments] = await Promise.all([
        fetchUser(),
        fetchPosts(),
        fetchComments()
    ]);
    return { user, posts, comments };
}
```

### 2. 적절한 타임아웃 설정

네트워크 요청에는 타임아웃을 설정하여 무한 대기를 방지하세요:

```javascript
function fetchWithTimeout(url, timeout = 5000) {
    return Promise.race([
        fetch(url),
        new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout')), timeout)
        )
    ]);
}

// 사용
try {
    const data = await fetchWithTimeout('https://api.example.com/data', 3000);
} catch (err) {
    console.error('요청 실패 또는 타임아웃:', err);
}
```

## 다른 언어와의 비교

| 항목 | JavaScript | Python | Java |
|------|-----------|--------|------|
| 스레드 모델 | 싱글스레드 + 이벤트 루프 | 멀티스레드 지원 | 멀티스레드 지원 |
| 비동기 지원 | 기본 내장 (Promise, async/await) | asyncio, async/await | CompletableFuture, async 라이브러리 |
| 블로킹 I/O | 기본은 논블로킹 | 기본은 블로킹 | 기본은 블로킹 |
| 주요 사용처 | 웹 프론트엔드, Node.js | 데이터 분석, 백엔드 | 엔터프라이즈 백엔드 |

JavaScript는 태생적으로 비동기 처리에 최적화되어 있습니다. 웹 브라우저 환경에서 UI를 멈추지 않으면서 네트워크 요청을 처리해야 했기 때문이죠.

## 마치며

블로킹/논블로킹과 동기/비동기는 비동기 프로그래밍의 핵심 개념입니다. 이 두 축을 명확히 이해하면 더 효율적이고 반응성 좋은 애플리케이션을 만들 수 있습니다.

실무에서 가장 중요한 건:
- **블로킹/논블로킹은 "지금 기다릴까?"(제어권)에 관한 것**
- **동기/비동기는 "결과는 언제 받을까?"(결과 흐름)에 관한 것**
- **JavaScript는 싱글스레드지만 이벤트 루프 덕분에 비동기 처리가 가능하다**
- **콜백 대신 Promise와 async/await를 활용하여 가독성 높은 코드를 작성하자**
- **순차적으로 기다릴 필요 없는 작업은 Promise.all로 병렬 처리하자**

비동기 프로그래밍은 처음에는 어렵게 느껴질 수 있지만, 개념을 명확히 이해하고 나면 강력한 도구가 됩니다. 하나씩 연습하면서 익숙해지시길 바랍니다!

## 참고 자료

- [MDN Web Docs - Asynchronous JavaScript](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Asynchronous)
- [Node.js 공식 문서 - Blocking vs Non-Blocking](https://nodejs.org/en/docs/guides/blocking-vs-non-blocking/)
- [JavaScript.info - Async/await](https://javascript.info/async-await)
- [MDN Web Docs - Promise](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise)

---

*작성일: 2025-11-05*
