# 안전하고 무결한 엔티티 만들기 전략

> Devon의 엔티티 작성 컨벤션과 설계 원칙

## 들어가며

엔티티는 도메인의 핵심이자, 비즈니스 로직의 중심이다. 잘못 설계된 엔티티는 시스템 전체의 무결성을 해칠 수 있다. 이 문서는 내가 실무에서 겪은 수많은 시행착오를 거쳐 정립한 엔티티 작성 컨벤션을 다룬다.

주요 니즈는 다음과 같았다:
- **무결성 보장**: 잘못된 상태의 엔티티가 생성되지 않도록
- **캡슐화**: 외부에서 엔티티의 내부 상태를 마음대로 변경하지 못하도록
- **명확한 의도**: 코드만 봐도 어떤 비즈니스 로직인지 이해할 수 있도록
- **유지보수성**: DB 스키마 변경이 코드에 미치는 영향 최소화

---

## 1. 클래스 레벨 설정과 생성 통제

### 기본 어노테이션 구조

```java
@Entity
@Getter
@Builder(access = AccessLevel.PROTECTED)
@AllArgsConstructor(access = AccessLevel.PROTECTED)
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "users")
public class User extends BaseEntity {
    // ...
}
```

### Setter를 금지하는 이유

엔티티에 Setter를 두지 않는 이유는 **불변성 보장**과 **의도의 명확성** 때문이다.

```java
// 나쁜 예 - 의도를 알 수 없다
user.setStatus("ACTIVE");
user.setLastLoginAt(Instant.now());

// 좋은 예 - 비즈니스 의도가 명확하다
user.login();
```

Setter를 허용하면 비즈니스 로직이 서비스 레이어에 흩어지고, 엔티티는 단순한 데이터 컨테이너로 전락한다. 모든 상태 변경을 비즈니스 메서드로 제한함으로써 도메인 로직을 엔티티 안에 응집시킬 수 있다.

### Builder와 생성자 접근 제한

Builder와 생성자를 `PROTECTED`로 제한하는 이유는 **외부에서 잘못된 엔티티를 생성하는 것을 방지**하기 위함이다.

```java
// 이렇게 하면 컴파일 에러
User user = User.builder()
    .email("")  // 빈 이메일!
    .name(null) // null!
    .build();
```

대신 팩토리 메서드를 통해서만 생성하도록 강제한다:

```java
public static User create(String email, String name, String password) {
    validateCreate(email, name, password);

    return User.builder()
            .email(email)
            .name(name)
            .password(passwordEncoder.encode(password))
            .status(UserStatus.ACTIVE)
            .createdAt(Instant.now())
            .build();
}

private static void validateCreate(String email, String name, String password) {
    Assert.hasText(email, "email required");
    Assert.hasText(name, "name required");
    Assert.hasText(password, "password required");

    if (email.length() > 255) {
        throw new IllegalArgumentException("email too long");
    }
    if (name.length() > 100) {
        throw new IllegalArgumentException("name too long");
    }
}
```

이 방식의 장점:
1. **생성 시점 검증**: 잘못된 상태의 엔티티가 생성될 수 없다
2. **기본값 보장**: status, createdAt 같은 필드의 초기값이 누락되지 않는다
3. **단일 진입점**: 엔티티 생성 로직이 한 곳에 모여 있어 관리가 쉽다
4. **무결성 보장**: validation을 통과한 데이터만 엔티티로 만들어진다

---

## 2. ID 생성 전략

### 주요 생성 전략 비교

JPA에서 제공하는 ID 생성 전략은 다음과 같다:

| 전략 | 설명 | 장점 | 단점 |
|-----|------|-----|-----|
| **IDENTITY** | DB의 AUTO_INCREMENT 사용 | 구현 간단, DB가 ID 관리 | bulk insert 성능 이슈 |
| **SEQUENCE** | DB 시퀀스 사용 | 성능 최적화 가능 | 시퀀스 지원 DB만 가능 |
| **TABLE** | 별도 테이블로 ID 관리 | DB 종류 무관 | 성능 저하, 복잡성 증가 |
| **AUTO** | DB에 따라 자동 선택 | 편리함 | 명시적이지 않음 |

### IDENTITY를 선택한 이유

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

나는 대부분의 경우 **IDENTITY** 전략을 사용한다. 이유는:

1. **단순함**: 별도의 시퀀스 객체나 테이블 관리가 필요 없다
2. **MySQL/MariaDB 친화적**: 주로 사용하는 DB와 자연스럽게 매칭된다
3. **직관성**: DB의 AUTO_INCREMENT와 1:1 매핑되어 이해하기 쉽다
4. **충분한 성능**: 대부분의 서비스에서 bulk insert 성능 이슈는 드물다

물론 대용량 batch insert가 중요한 시스템이라면 SEQUENCE를 고려할 수 있지만, 실무에서 그런 경우는 생각보다 드물었다.

---

## 3. 필드 정의 전략

### 컬럼명 명시 원칙

```java
@Column(name = "user_email", nullable = false, length = 255)
private String email;
```

**필드명과 DB 컬럼명이 일치하더라도 `name` 속성을 반드시 명시한다.**

이유는 **DB 변경이 JPA에 영향을 주지 않도록** 하기 위함이다:

```java
// DB에서 컬럼명이 user_email -> member_email로 변경되어도
// Java 필드명 email은 그대로 유지 가능
@Column(name = "member_email", nullable = false, length = 255)
private String email;
```

반대로 Java 필드명을 리팩토링해도 DB 컬럼명은 영향받지 않는다:

```java
// Java 필드명을 emailAddress로 변경해도 DB는 그대로
@Column(name = "user_email", nullable = false, length = 255)
private String emailAddress;
```

이는 **DB 스키마와 도메인 모델의 독립성**을 보장한다. 특히 레거시 DB를 다룰 때 유용하다.

### 컬럼 속성 지정 원칙

```java
@Column(name = "user_name", nullable = false, length = 100)
private String name;

@Column(name = "phone_number", nullable = true, unique = true, length = 20)
private String phoneNumber;
```

- `nullable`: 필수 여부를 명시적으로 표현
- `unique`: 유니크 제약을 코드로 문서화
- `length`: DDL 생성 시 정확한 길이 반영

### Enum 타입 전략

```java
@Enumerated(EnumType.STRING)
@Column(name = "user_status", nullable = false)
private UserStatus status;
```

**EnumType.ORDINAL이 아닌 STRING을 사용하는 이유:**

```java
// ORDINAL을 사용하면
public enum UserStatus {
    ACTIVE,   // 0
    INACTIVE, // 1
    DELETED   // 2
}

// 나중에 순서가 바뀌면 큰일난다
public enum UserStatus {
    PENDING,  // 0 (새로 추가!)
    ACTIVE,   // 1 (기존 0 -> 1로 변경됨!)
    INACTIVE, // 2
    DELETED   // 3
}
```

ORDINAL을 사용하면:
- Enum 순서 변경 시 기존 데이터가 깨진다
- DB 데이터만 봐서는 무슨 상태인지 알 수 없다 (0, 1, 2가 뭘 의미하는지?)

STRING을 사용하면:
- Enum 순서가 바뀌어도 안전하다
- DB에 "ACTIVE", "INACTIVE"로 저장되어 가독성이 높다
- 중간에 새 상태를 추가해도 문제없다

약간의 저장 공간을 더 사용하지만, **안정성과 가독성**이 훨씬 중요하다.

### 시간 필드 전략

```java
@Column(name = "last_login_at")
private Instant lastLoginAt;
```

**LocalDateTime이 아닌 Instant를 사용하는 이유:**

1. **타임존 문제 해결**: Instant는 UTC 기준 절대 시간이다
   ```java
   // LocalDateTime은 타임존 정보가 없어서 혼란스럽다
   LocalDateTime loginTime = LocalDateTime.now(); // 어느 나라 시간?

   // Instant는 명확하다
   Instant loginTime = Instant.now(); // UTC 기준 절대 시간
   ```

2. **글로벌 서비스 대응**: 서버가 여러 나라에 있어도 일관된 시간 처리
3. **DB 독립성**: MySQL의 TIMESTAMP, PostgreSQL의 TIMESTAMPTZ와 자연스럽게 매핑
4. **비교 연산 안전성**: 타임존 변환 없이 직접 비교 가능

사용자에게 보여줄 때만 해당 지역의 LocalDateTime으로 변환하면 된다.

참고로 생성/수정 시간은 BaseEntity를 상속받아 자동 관리한다:

```java
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private Instant createdAt;

    @LastModifiedDate
    @Column(name = "updated_at", nullable = false)
    private Instant updatedAt;
}
```

---

## 4. 비즈니스 메서드

엔티티의 상태를 변경하는 모든 로직은 **비즈니스 메서드**로 작성한다.

### 단순 변경 메서드

```java
public void changeName(String newName) {
    Assert.hasText(newName, "name required");
    if (newName.length() > 100) {
        throw new IllegalArgumentException("name too long");
    }
    this.name = newName;
}

public void changePhoneNumber(String newPhoneNumber) {
    if (newPhoneNumber != null && newPhoneNumber.length() > 20) {
        throw new IllegalArgumentException("phone number too long");
    }
    this.phoneNumber = newPhoneNumber;
}
```

### 상태 변경 메서드

```java
public void deactivate() {
    this.status = UserStatus.INACTIVE;
}

public void delete() {
    this.status = UserStatus.DELETED;
}
```

### 도메인 로직 메서드

```java
public void login() {
    this.lastLoginAt = Instant.now();
    this.loginCount++;
}

public void changePassword(String oldPassword, String newPassword, PasswordEncoder encoder) {
    if (!encoder.matches(oldPassword, this.password)) {
        throw new IllegalArgumentException("invalid old password");
    }
    Assert.hasText(newPassword, "new password required");
    this.password = encoder.encode(newPassword);
}
```

### 조회 메서드

```java
public boolean isActive() {
    return this.status == UserStatus.ACTIVE;
}

public boolean isDeleted() {
    return this.status == UserStatus.DELETED;
}

public boolean canLogin() {
    return isActive() && this.password != null;
}
```

이런 메서드들은 서비스 레이어의 코드를 훨씬 명확하게 만든다:

```java
// Before
if (user.getStatus() == UserStatus.ACTIVE && user.getPassword() != null) {
    // ...
}

// After
if (user.canLogin()) {
    // ...
}
```

---

## 5. 검증 전략: 최후의 방어선

### 엔티티 검증의 위치

엔티티의 검증 로직은 **최후의 방어선**이다. 이상적으로는:

1. **Controller**: 요청 형식 검증 (`@Valid`, `@NotBlank` 등)
2. **Service**: 비즈니스 규칙 검증 (중복 체크, 권한 확인 등)
3. **Entity**: 도메인 무결성 검증 (필수값, 길이 제한 등)

엔티티까지 내려온 데이터는 **이미 검증된 데이터**여야 한다. 엔티티 검증은 "만약을 위한 안전장치"다.

### 필수값 검증

```java
private static void validateCreate(String email, String name) {
    Assert.hasText(email, "email required");
    Assert.hasText(name, "name required");
}
```

### 길이 검증

```java
if (email.length() > 255) {
    throw new IllegalArgumentException("email too long");
}
```

### Nullable 필드 검증

```java
if (phoneNumber != null && phoneNumber.length() > 20) {
    throw new IllegalArgumentException("phone number too long");
}
```

### 순수 예외를 사용하는 이유

엔티티 검증에서는 커스텀 예외(CustomException)가 아닌 **순수 예외**(IllegalArgumentException, IllegalStateException)를 사용한다.

이유는 복합적이다:

1. **책임 소재 명확화**
   ```java
   // 엔티티 검증 실패 = 백엔드 개발자의 실수
   // 이런 예외가 발생하면 안 된다
   throw new IllegalArgumentException("email required");
   ```
   이 예외가 발생했다는 것은 상위 레이어의 검증이 누락되었다는 의미다. 즉, **백엔드 개발자가 처리해야 할 버그**다.

2. **도메인의 순수성**
   ```java
   // 나쁜 예 - 도메인이 예외 클래스에 의존
   throw new EmailTooLongException();

   // 좋은 예 - 순수한 도메인
   throw new IllegalArgumentException("email too long");
   ```
   도메인 레이어에 커스텀 예외를 두면, 예외 클래스가 늘어날수록 도메인이 복잡해진다.

3. **예외 처리 전략 구분**
   - **비즈니스 예외**(CustomException): 사용자에게 친절한 메시지 반환
   - **검증 예외**(IllegalArgumentException): 500 에러로 로깅하고 개발자가 수정

4. **의도 전달**
   ```java
   // 이 예외는 "절대 발생하면 안 되는" 예외임을 명시
   throw new IllegalArgumentException("name required");
   ```

결과적으로 엔티티는 외부 의존성 없이 순수하게 유지되고, 예외 발생 시 책임 소재가 명확해진다.

---

## 6. 코드 구조 순서

일관된 구조는 가독성을 높인다. 다음 순서를 따른다:

```java
@Entity
@Getter
@Builder(access = AccessLevel.PROTECTED)
@AllArgsConstructor(access = AccessLevel.PROTECTED)
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Table(name = "users")
public class User extends BaseEntity {

    // 1. ID
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    // 2. 일반 컬럼 (비즈니스 의미 순서대로)
    @Column(name = "user_email", nullable = false, unique = true, length = 255)
    private String email;

    @Column(name = "user_name", nullable = false, length = 100)
    private String name;

    @Column(name = "password", nullable = false)
    private String password;

    // 3. Enum
    @Enumerated(EnumType.STRING)
    @Column(name = "user_status", nullable = false)
    private UserStatus status;

    // 4. 시간 필드
    @Column(name = "last_login_at")
    private Instant lastLoginAt;

    // 5. 팩토리 메서드
    public static User create(String email, String name, String password) {
        validateCreate(email, name, password);
        return User.builder()
                .email(email)
                .name(name)
                .password(password)
                .status(UserStatus.ACTIVE)
                .build();
    }

    // 6. 비즈니스 메서드 (public)
    public void login() {
        this.lastLoginAt = Instant.now();
    }

    public void changeName(String newName) {
        Assert.hasText(newName, "name required");
        this.name = newName;
    }

    // 7. 조회 메서드 (public)
    public boolean isActive() {
        return this.status == UserStatus.ACTIVE;
    }

    // 8. 검증 메서드 (private static)
    private static void validateCreate(String email, String name, String password) {
        Assert.hasText(email, "email required");
        Assert.hasText(name, "name required");
        Assert.hasText(password, "password required");
    }
}
```

---

## 7. 핵심 원칙 정리

### 캡슐화
모든 상태 변경은 비즈니스 메서드를 통해서만 가능하다. 필드를 직접 변경하는 코드는 존재하지 않는다.

### 불변성
Setter를 사용하지 않는다. 필요한 경우 명확한 이름의 비즈니스 메서드를 만든다.

### 생성 통제
팩토리 메서드 + protected 생성자로 잘못된 엔티티 생성을 원천 차단한다.

### 검증 집중화
생성/변경 시점에 즉시 검증한다. 검증되지 않은 상태의 엔티티는 존재할 수 없다.

### 명확한 네이밍
코드만 봐도 비즈니스 의도가 명확히 드러나야 한다. `setStatus()`보다 `deactivate()`가 낫다.

### 단일 책임
한 메서드는 한 가지 일만 한다. `login()`은 로그인 시간을 기록하는 일만 한다.

### 독립성
DB 스키마 변경이 도메인 모델에 영향을 주지 않도록, 그 반대도 마찬가지로 설계한다.

---

## 마치며

좋은 엔티티는 그 자체로 비즈니스를 설명한다. 코드를 읽는 것만으로 도메인 규칙을 이해할 수 있어야 한다.

이 컨벤션은 수많은 실패와 리팩토링을 거쳐 만들어졌다. 완벽하지 않지만, 지금까지 경험한 대부분의 상황에서 효과적이었다.

중요한 건 **왜 이렇게 하는가**를 이해하는 것이다. 맥락이 다르다면 규칙을 깨는 것도 두려워하지 말자. 다만, 그 이유를 명확히 설명할 수 있어야 한다.
